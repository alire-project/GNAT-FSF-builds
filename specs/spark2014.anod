from e3.anod.helper import Make
from e3.anod.loader import spec
from e3.anod.package import SourceBuilder
from e3.anod.spec import Anod
from e3.fs import cp, mv, sync_tree, ls, rm, mkdir
from e3.os.fs import chmod
import os


class SPARK2014(spec("common")):
    @property
    def version(self):
        return "13.1.0"

    @property
    def tarball(self):
        return "spark2014-%s.tar.gz" % self.version

    @property
    def exec_suffix(self):
        if self.env.host.os.name == "windows":
            return ".exe"
        else:
            return ""

    @property
    def gcc_tarball(self):
        return "gcc-%s.tar.gz" % self.version

    @property
    def cvc5_binary(self):
        if self.env.host.os.name == "windows":
            fn = "cvc5-Win64.exe"
        elif self.env.host.os.name == "darwin":
            fn = "cvc5-macOS"
        else:
            fn = "cvc5-linux"
        return fn

    @property
    def z3_zip(self):
        if self.env.host.os.name == "windows":
            fn = "z3-4.12.2-x64-win.zip"
        elif self.env.host.os.name == "darwin":
            fn = "z3-4.12.12-x64-osx-10.16.zip"
        else:
            fn = "z3-4.12.2-x64-glibc-2.31.zip"
        return fn

    @property
    def source_pkg_build(self):
        return [
            self.HTTPSSourceBuilder(
                name=self.gcc_tarball,
                url="https://ftp.gnu.org/gnu/gcc/gcc-%s/%s"
                % (self.version, self.gcc_tarball),
            ),
            self.HTTPSSourceBuilder(
                name=self.tarball,
                url="https://github.com/adacore/spark2014/tarball/fsf-13",
            ),
            self.HTTPSSourceBuilder(
                name=self.cvc5_binary,
                url="https://github.com/cvc5/cvc5/releases/download/cvc5-1.0.5/%s"
                % self.cvc5_binary,
            ),
            self.HTTPSSourceBuilder(
                name=self.z3_zip,
                url="https://github.com/Z3Prover/z3/releases/download/z3-4.12.2/%s"
                % self.z3_zip,
            ),
        ]

    @property
    def build_source_list(self):
        return [
            Anod.Source(name=self.tarball, publish=True, dest=""),
            Anod.Source(name=self.gcc_tarball, publish=True, dest="gcc"),
            Anod.Source(
                name=self.cvc5_binary, publish=True, unpack_cmd=cp, dest="cvc5"
            ),
            Anod.Source(name=self.z3_zip, publish=True, dest="z3"),
        ]

    build_space_name = "spark2014"

    @property
    def build_deps(self):
        deps = [
            Anod.Dependency("gcc"),
            Anod.Dependency("why3"),
            Anod.Dependency("alt-ergo"),
            Anod.Dependency("gmp", qualifier="shared_lib"),
            Anod.Dependency("gprbuild"),
            Anod.Dependency("gnatcoll"),
            Anod.Dependency("xmlada"),
            Anod.Dependency("libgpr"),
        ]
        return deps

    @Anod.primitive()
    def build(self):
        ada_dir = os.path.join(self["SRC_DIR"], "gcc", "gcc", "ada")
        gnat_src_dir = os.path.join(self["SRC_DIR"], "gnat2why", "gnat_src")
        sync_tree(ada_dir, gnat_src_dir, delete=True)

        make = Make(
            self,
            makefile=os.path.join(self["SRC_DIR"], "Makefile"),
            exec_dir=self["SRC_DIR"],
        )
        for dep in self.deps:
            self.deps[dep].setenv()
        make("all-nightly", jobs=1)

        self.install()


    def install(self):
        libexec_spark = os.path.join(self["INSTALL_DIR"], "libexec", "spark")
        libexec_spark_bin = os.path.join(libexec_spark, "bin")

        mkdir (libexec_spark)
        mkdir (libexec_spark_bin)

        _bin = os.path.join(self["INSTALL_DIR"], "bin")
        sync_tree(os.path.join(self["SRC_DIR"], "install"), self["INSTALL_DIR"])

        sync_tree(self.deps["gcc"]["INSTALL_DIR"], libexec_spark, delete=False)
        # Remove all gnat* executables except gnatbind/gnatls, only keep
        # gcc/gnatbind/gpr* executables.
        for glob in ["gnat*", "gdb*", "gcov*", "ld*", "nm", "g++", "ar",
                     "as", "addr2line", "elfedit", "c++*", "lto-dump",
                     "ranlib", "objdump", "size", "readelf", "strings",
                     "strip"]:
            files = ls(os.path.join(libexec_spark, "bin", glob))
            for f in files:
                if (
                    not os.path.basename(f).startswith("gnatbind")
                    and not os.path.basename(f).startswith("gnatls")
                    and not os.path.basename(f).startswith("gnat_server")
                    and not os.path.basename(f).startswith("gnatwhy3")
                    ):
                    rm(f)

        sync_tree(self.deps["why3"]["INSTALL_DIR"], libexec_spark, delete=False)
        sync_tree(self.deps["alt-ergo"]["INSTALL_DIR"], libexec_spark, delete=False)
        sync_tree(self.deps["gprbuild"]["INSTALL_DIR"], libexec_spark, delete=False)
        sync_tree(self.deps["gmp"]["INSTALL_DIR"], libexec_spark, delete=False)

        sync_tree(os.path.join(self["SRC_DIR"], "z3"), libexec_spark, delete=False)
        cvc5_binary_name = "cvc5.exe" if self.env.host.os.name == "windows" else "cvc5"
        cvc5_binary_name = os.path.join(libexec_spark_bin, cvc5_binary_name)
        cp(
            os.path.join(self["SRC_DIR"], "cvc5", self.cvc5_binary),
            cvc5_binary_name
        )

        for fn in [
            "gnat2why",
            "spark_memcached_wrapper",
            "spark_report",
            "spark_semaphore_wrapper",
        ]:
            mv(
                os.path.join(_bin, fn + self.exec_suffix),
                libexec_spark_bin
            )
        mv (os.path.join(_bin, "target.atp"), libexec_spark_bin)

        rm(os.path.join(libexec_spark, "share", "doc"), True)

        # delete alt-ergo libs, these are not used by SPARK and take quite
        # some space
        for dir in ["alt-ergo", "alt-ergo-lib", "alt-ergo-parsers"]:
            rm(os.path.join(libexec_spark, "lib", dir), True)

        for exe in ["cvc5", "gnat_server", "gnatwhy3", "alt-ergo"]:
            chmod("a+x",
                  os.path.join(libexec_spark_bin,
                               (exe + (".exe" if self.env.host.os.name == "windows"
                                        else ""))))

        for f in ls(os.path.join(libexec_spark, "bin", "why3*")):
            chmod("a+x", f)
